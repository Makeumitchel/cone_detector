# -*- coding: utf-8 -*-
"""utils_.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fAGO7YjOCzQWWMNIbSfFDYLm4wXKZpQj
"""

import numpy
import pandas
import tensorflow as tf
from tensorflow import keras
import skimage
import cv2
import matplotlib
import os


def cut_image(img, cut=3, overlap=16):
  images=[]
  h,w,c = numpy.shape(img)
  coeff = (c==3)*127.5
  margin_img = numpy.ones((h+2*overlap, w+2*overlap , c))*coeff
  margin_img[overlap:-overlap, overlap:-overlap,:]=img
  dh, dw=int(h/cut), int(w/cut)
  for i in range(cut):
    for j in range(cut):
      h1,h2=int(dh*i), int(dh*(i+1)+2*overlap)
      w1,w2=int(dw*j), int(dw*(j+1)+2*overlap)
      #add overlap
      h1,h2=numpy.max([h1,0]), numpy.min([h2, h+2*overlap])
      w1,w2=numpy.max([w1,0]) , numpy.min([w2, w+2*overlap])
      im=margin_img[h1: h2, w1:w2,:]
      images.append(im)
  return images

def assemble_mask(masks, cut=3, overlap=16):
  [_, h0, w0, _] = numpy.shape(masks[0])
  h, w = h0-2*overlap, w0-2*overlap
  mask = numpy.zeros((cut*h, cut*w))
  dh, dw=h, w
  for i in range(cut):
    for j in range(cut):
      h1,h2=int(dh*i), int(dh*(i+1))
      w1,w2=int(dw*j), int(dw*(j+1))
      m=masks[0]
      mask[h1:h2, w1:w2]= m[0, overlap:-overlap, overlap:-overlap, 0]
      masks.pop(0)
  return mask

def draw(info, img, bbox, coordinates, width=10):
  [img_name, y_hat, y_hat_3d]=info
  im=numpy.copy(img)
  # draw box
  [minr, minc, maxr, maxc]=bbox
  bbox2=[minr+width, minc+width, maxr-width, maxc-width]
  [minr2, minc2, maxr2, maxc2]=bbox2
  im[minr:maxr, minc:maxc,0]=numpy.zeros_like(im[minr:maxr, minc:maxc, 0]) # R
  im[minr:maxr, minc:maxc,1]=numpy.ones_like(im[minr:maxr, minc:maxc, 1])*255 # G
  im[minr:maxr, minc:maxc,2]=numpy.zeros_like(im[minr:maxr, minc:maxc, 2]) #B
  im[minr2:maxr2, minc2:maxc2, :]=img[minr2:maxr2, minc2:maxc2, :]
  # draw coordinates
  fig3, (ax1)=matplotlib.pyplot.subplots(1,1,figsize=(14,14))
  ax1.imshow(im)
  title=str(img_name)+' / Detection 2d = '+str(y_hat)+ ' cones / Prediction 3d = '+str(y_hat_3d)+' cones'
  ax1.set_title(title)
  ax1.plot(coordinates[:, 1], coordinates[:, 0], 'r.')
  

def dice_coefficient(y_true, y_pred):
  numerator = 2 * tf.reduce_sum(y_true * y_pred)
  denominator = tf.reduce_sum(y_true + y_pred)
  return numerator / (denominator + tf.keras.backend.epsilon())