# -*- coding: utf-8 -*-
"""detect_.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FNzhFtRcdFemhUKhGuM6JWdMXOWO4_j2
"""

from tensorflow import keras
import numpy
import pandas
import tensorflow
import skimage
import cv2
import matplotlib
import  os
from skimage.io import imread, imshow
from skimage.feature import  peak_local_max
from utils import draw, cut_image, assemble_mask, dice_coefficient


class Detector:

  def __init__(self, img_dir):

    self.img_dir = './data/'+img_dir
    path_cone = './models/cone_model.h5'
    self.model_cone = keras.models.load_model(path_cone, custom_objects={'dice_coefficient': dice_coefficient})
    path_tree='./models/tree_model.h5'
    self.model_tree = keras.models.load_model( path_tree, custom_objects={'dice_coefficient': dice_coefficient})
    self.img_shape = ( 1920, 1440 , 3) # height, width, channels
    self.tree_shape = (832, 832, 3)
    self.o=16 # overlap
    self.k=3 # nb of img cuts


  def preprocess_tree(self, img):
    w, h, c= self.tree_shape
    img =cv2.resize(img, (w , h ), interpolation = cv2.INTER_AREA)
    img= numpy.reshape(img,  (1, w , h , c) )
    return img

  def postprocess_tree(self, mask):
    h, w, c= self.img_shape
    new_h, new_w ,new_c = self.tree_shape
    mask = numpy.reshape(mask, ( new_h, new_w) )
    mask = cv2.resize(mask, (w, h), interpolation = cv2.INTER_AREA)
    mask_centroid = [h//2, w//2]
    # filter
    filtered_mask = skimage.filters.gaussian(mask , sigma=10)
    # label image regions
    thr=0.07
    label_mask = skimage.measure.label(filtered_mask >thr, background=0, connectivity=2) 
    regions = skimage.measure.regionprops(label_mask )
    min=numpy.inf
    for region in regions:
      centroid=region.centroid
      distance= numpy.sqrt((centroid[0] - mask_centroid[0])**2+(centroid[1] - mask_centroid[1])**2)
      if region.area>20000 and distance<min:
        min=distance
        minr, minc, maxr, maxc=region.bbox
    # add margin and set limits
    margin = 200
    minr=0
    minc= numpy.max([minc-margin, 300])
    maxr= numpy.max( [numpy.min([maxr, h]), h-400])
    maxc= numpy.min([maxc+margin, w-300])
    bbox = [minr, minc, maxr, maxc]
    return bbox

  def preprocess_cones(self, img):
    h, w ,c = self.img_shape
    new_w = int(w/self.k+2*self.o) # once cut and overlapped
    new_h = int(h/self.k+2*self.o) 
    img = cv2.resize(img, (w, h), interpolation = cv2.INTER_AREA)
    # compute mask
    images = cut_image(img, cut=self.k, overlap=self.o)
    for i in range(len(images)):
      images[i]= numpy.reshape(images[i],  (1, new_h, new_w, c) )
    return images

  def postprocess_cones(self, masks,  bbox ):
    mask = assemble_mask(masks, cut=self.k , overlap=self.o)
    [minr, minc, maxr, maxc]=bbox
    new_mask= numpy.zeros_like(mask)
    new_mask[minr:maxr, minc:maxc]=mask[minr:maxr, minc:maxc]
    # coordinate with local min
    coordinates =  skimage.feature.peak_local_max(new_mask, min_distance=3, threshold_abs=0.04)
    nb = len(coordinates)
    return nb, coordinates

  def detect(self, img_name, check=True, a=1.30 , b=-1.02):
    # verify img_name exists
    if check==True:
      img_list = os.listdir(self.img_dir)
      if img_name not in img_list:
        print('Wrong image name: please pick in ', img_list)

    img_path= os.path.join( self.img_dir, img_name)
    img = skimage.io.imread(img_path)[:,:,:]
    #find central tree
    im= self.preprocess_tree(img)
    mask = self.model_tree.predict(im)
    bbox=self.postprocess_tree(mask)
    # find nb cones
    masks = []
    images = self.preprocess_cones(img)
    for im in images:
      mask = self.model_cone.predict(im)
      masks.append(mask)
    y_hat , coordinates = self.postprocess_cones( masks,  bbox)
    # linear realtionship between 2d predictions and 3d predictions 
    y_hat_3d = int(numpy.exp(b)*y_hat**a)
    if check==True:
      info=[img_name, y_hat, y_hat_3d]
      draw(info, img, bbox, coordinates, width=10)
    else:
      return y_hat, y_hat_3d, coordinates, img

  def run_through_folder(self, img_dir):
    data=[]
    self.img_dir='./data/'+img_dir
    img_list = os.listdir(self.img_dir)
    for img_name in img_list:
      y_hat, y_hat_3d, _, _= self.detect(img_name, check=False)
      print('Image:', img_name, '; pred_2d = ',y_hat, '; pred_3d = ', y_hat_3d)
      data.append([img_name, y_hat, y_hat_3d])
    df = pandas.DataFrame(data, columns=['img_name', 'pred_2d', 'pred_3d'])
    path='./predictions/prediction_'+str(img_dir)+'.csv'
    df.to_csv(path, index=False)
    print('Predictions saved to drive/MyDrive/cone_detector/', path)